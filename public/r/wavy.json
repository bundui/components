{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "wavy",
  "type": "registry:block",
  "title": "Wavy",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "components/core/backgrounds/wavy.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\n// Zoom factor for the visual pattern.\nconst ZOOM_FACTOR = 0.3;\n\n// Base wave amplitude in domain warping.\nconst BASE_WAVE_AMPLITUDE = 0.2;\n\n// Additional factor for random amplitude variations.\n// waveAmp = BASE_WAVE_AMPLITUDE + RANDOM_WAVE_FACTOR * noise2D(...)\nconst RANDOM_WAVE_FACTOR = 0.15;\n\n// Frequency multiplier for wave domain warp.\nconst WAVE_FREQUENCY = 4.0;\n\n// Time speed factor (overall speed of animation).\nconst TIME_FACTOR = 0.25;\n\n// Swirl strength near the center.\nconst BASE_SWIRL_STRENGTH = 1.2;\n\n// Finer swirl timing factor.\nconst SWIRL_TIME_MULT = 5.0;\n\n// Additional swirl effect modulated by noise.\nconst NOISE_SWIRL_FACTOR = 0.2;\n\n// Number of fractal noise octaves in fbm (must be integer).\nconst FBM_OCTAVES = 10;\n\n// 20-step palette of blues.\n// If the darkest color is used, alpha=0 => total transparency in darkest areas.\nconst seaColors = [\n  [0.0, 0.02, 0.05],\n  [0.0, 0.04, 0.08],\n  [0.0, 0.06, 0.12],\n  [0.0, 0.08, 0.18],\n  [0.0, 0.1, 0.24],\n  [0.0, 0.14, 0.32],\n  [0.0, 0.2, 0.4],\n  [0.0, 0.24, 0.48],\n  [0.0, 0.3, 0.55],\n  [0.05, 0.35, 0.6],\n  [0.08, 0.4, 0.65],\n  [0.1, 0.45, 0.7],\n  [0.15, 0.5, 0.75],\n  [0.2, 0.58, 0.8],\n  [0.25, 0.65, 0.85],\n  [0.3, 0.72, 0.9],\n  [0.4, 0.78, 0.92],\n  [0.5, 0.85, 0.95],\n  [0.7, 0.9, 0.97],\n  [0.85, 0.95, 1.0]\n];\n\n////////////////////////////////////////////////////////////////////////////////\n// DYNAMIC FRAGMENT SHADER BUILDER\n////////////////////////////////////////////////////////////////////////////////\n\nfunction buildFragmentShader(): string {\n  // Force integer for the for-loop.\n  const fbmOctavesInt = Math.floor(FBM_OCTAVES);\n\n  // Convert seaColors array to GLSL array of vec3.\n  const colorArraySrc = seaColors.map((c) => `vec3(${c[0]}, ${c[1]}, ${c[2]})`).join(\",\\n  \");\n\n  return `#version 300 es\n\nprecision highp float;\nout vec4 outColor;\n\nuniform vec2 uResolution;\nuniform float uTime;\n\n#define NUM_COLORS 20\n\n// 20-step palette of blues.\nvec3 seaColors[NUM_COLORS] = vec3[](\n  ${colorArraySrc}\n);\n\n// ----------------------------------------------------------\n// Perlin-like noise\n// ----------------------------------------------------------\nvec3 permute(vec3 x) {\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat noise2D(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n    -0.577350269189626,\n    0.024390243902439\n  );\n\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = mod(i, 289.0);\n  vec3 p = permute(\n    permute(i.y + vec3(0.0, i1.y, 1.0)) +\n    i.x + vec3(0.0, i1.x, 1.0)\n  );\n\n  vec3 m = max(\n    0.5 - vec3(\n      dot(x0, x0),\n      dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)\n    ),\n    0.0\n  );\n  m = m * m;\n  m = m * m;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.792843 - 0.853734 * (a0 * a0 + h * h);\n\n  vec3 g;\n  g.x  = a0.x  * x0.x + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n  return 130.0 * dot(m, g);\n}\n\n// ----------------------------------------------------------\n// Fractional Brownian Motion\n// ----------------------------------------------------------\nfloat fbm(vec2 st) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float freq = 1.0;\n  for (int i = 0; i < ${fbmOctavesInt}; i++) {\n    value += amplitude * noise2D(st * freq);\n    freq *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\nvoid main() {\n  // Normalize coords to [-1,1]\n  vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;\n  uv.x *= uResolution.x / uResolution.y;\n\n  // Zoom in so pattern is bigger and less obviously repeated\n  uv *= float(${ZOOM_FACTOR});\n\n  // Time factor for wave domain warp\n  float t = uTime * float(${TIME_FACTOR});\n\n  // Random amplitude that changes over time\n  float waveAmp = float(${BASE_WAVE_AMPLITUDE}) + float(${RANDOM_WAVE_FACTOR})\n                  * noise2D(vec2(t, 27.7));\n\n  // Sine-based domain warp\n  float waveX = waveAmp * sin(uv.y * float(${WAVE_FREQUENCY}) + t);\n  float waveY = waveAmp * sin(uv.x * float(${WAVE_FREQUENCY}) - t);\n  uv.x += waveX;\n  uv.y += waveY;\n\n  // Additional swirl near center\n  float r = length(uv);\n  float angle = atan(uv.y, uv.x);\n  float swirlStrength = float(${BASE_SWIRL_STRENGTH})\n                        * (1.0 - smoothstep(0.0, 1.0, r));\n\n  angle += swirlStrength * sin(uTime + r * float(${SWIRL_TIME_MULT}));\n  uv = vec2(cos(angle), sin(angle)) * r;\n\n  // Evaluate fractal noise\n  float n = fbm(uv);\n\n  // Additional swirl effect modulated by noise\n  float swirlEffect = float(${NOISE_SWIRL_FACTOR})\n                      * sin(t + n * 3.0);\n  n += swirlEffect;\n\n  // Convert noise to [0..1]\n  float noiseVal = 0.5 * (n + 1.0);\n\n  // Discrete palette sampling\n  float idx = clamp(noiseVal, 0.0, 1.0) * float(NUM_COLORS - 1);\n  int iLow = int(floor(idx));\n  int iHigh = int(min(float(iLow + 1), float(NUM_COLORS - 1)));\n  float f = fract(idx);\n\n  vec3 colLow = seaColors[iLow];\n  vec3 colHigh = seaColors[iHigh];\n  vec3 color = mix(colLow, colHigh, f);\n\n  // If it's the darkest color, set alpha=0 => total transparency\n  if (iLow == 0 && iHigh == 0) {\n    outColor = vec4(color, 0.0);\n  } else {\n    outColor = vec4(color, 1.0);\n  }\n}\n`;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// STATIC VERTEX SHADER\n////////////////////////////////////////////////////////////////////////////////\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nin vec2 aPosition;\n\nvoid main() {\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}`;\n\n////////////////////////////////////////////////////////////////////////////////\n// SHADER COMPILATION UTIL\n////////////////////////////////////////////////////////////////////////////////\nfunction createShaderProgram(\n  gl: WebGL2RenderingContext,\n  vsSource: string,\n  fsSource: string\n): WebGLProgram | null {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  if (!vertexShader) return null;\n\n  gl.shaderSource(vertexShader, vsSource);\n  gl.compileShader(vertexShader);\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n    console.error(\"Vertex shader error:\", gl.getShaderInfoLog(vertexShader));\n    gl.deleteShader(vertexShader);\n    return null;\n  }\n\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  if (!fragmentShader) {\n    gl.deleteShader(vertexShader);\n    return null;\n  }\n\n  gl.shaderSource(fragmentShader, fsSource);\n  gl.compileShader(fragmentShader);\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n    console.error(\"Fragment shader error:\", gl.getShaderInfoLog(fragmentShader));\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n\n  const program = gl.createProgram();\n  if (!program) {\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Could not link WebGL program:\", gl.getProgramInfoLog(program));\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    gl.deleteProgram(program);\n    return null;\n  }\n\n  return program;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN REACT COMPONENT\n////////////////////////////////////////////////////////////////////////////////\nexport default function WavyBackground({\n  children,\n  className\n}: {\n  children: React.ReactNode;\n  className?: string;\n}) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current!;\n    if (!canvas) return;\n\n    // Build final fragment shader from above config\n    const fsSource = buildFragmentShader();\n\n    const gl = canvas.getContext(\"webgl2\", { alpha: true })!;\n    if (!gl) {\n      console.error(\"WebGL2 is not supported by your browser.\");\n      return;\n    }\n\n    // Enable blending for transparency\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Transparent background\n    gl.clearColor(0, 0, 0, 0);\n\n    // Resize canvas to fill screen\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    const program = createShaderProgram(gl, vertexShaderSource, fsSource);\n    if (!program) {\n      console.error(\"Failed to create shader program.\");\n      return;\n    }\n\n    gl.useProgram(program);\n\n    // Full-screen quad\n    const quadVertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n\n    const vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n\n    const vbo = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);\n\n    const aPositionLoc = gl.getAttribLocation(program, \"aPosition\");\n    gl.enableVertexAttribArray(aPositionLoc);\n    gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);\n\n    // Uniform locations\n    const uResolutionLoc = gl.getUniformLocation(program, \"uResolution\");\n    const uTimeLoc = gl.getUniformLocation(program, \"uTime\");\n\n    let startTime = performance.now();\n\n    function render() {\n      const currentTime = performance.now();\n      const elapsed = (currentTime - startTime) * 0.001; // seconds\n\n      if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n      }\n\n      gl.viewport(0, 0, canvas.width, canvas.height);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      gl.useProgram(program);\n      gl.bindVertexArray(vao);\n\n      gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);\n      gl.uniform1f(uTimeLoc, elapsed);\n\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n      requestAnimationFrame(render);\n    }\n\n    render();\n\n    const handleResize = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      gl.viewport(0, 0, canvas.width, canvas.height);\n    };\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      gl.deleteProgram(program);\n      gl.deleteBuffer(vbo);\n      gl.deleteVertexArray(vao);\n    };\n  }, []);\n\n  return (\n    <div className={cn(\"relative w-full overflow-hidden\", className)}>\n      <canvas ref={canvasRef} className=\"absolute inset-0\" style={{ background: \"transparent\" }} />\n      {children}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/wavy.tsx"
    },
    {
      "path": "lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib"
    }
  ]
}