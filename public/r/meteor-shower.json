{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "meteor-shower",
  "type": "registry:block",
  "title": "Meteor Shower",
  "dependencies": [
    "next-themes",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "components/core/backgrounds/meteor-shower.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { useTheme } from \"next-themes\";\nimport { cn } from \"@/lib/utils\";\n\ninterface Meteor {\n  x: number;\n  y: number;\n  size: number;\n  speed: number;\n  angle: number;\n  opacity: number;\n  tail: { x: number; y: number }[];\n  tailLength: number;\n}\n\ninterface ThemeColors {\n  background: string;\n  meteorHead: string;\n  meteorTailStart: string;\n  meteorTailMiddle: string;\n  meteorTailEnd: string;\n}\n\nexport default function MeteorShower({\n  children,\n  className\n}: {\n  children: React.ReactNode;\n  className?: string;\n}) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const meteorsRef = useRef<Meteor[]>([]);\n  const animationRef = useRef<number>(0);\n  const { theme } = useTheme();\n  const [mounted, setMounted] = useState(false);\n\n  // Avoid hydration mismatch\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // Initialize canvas dimensions\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (typeof window !== \"undefined\") {\n        setDimensions({\n          width: window.innerWidth,\n          height: window.innerHeight\n        });\n      }\n    };\n\n    updateDimensions();\n    window.addEventListener(\"resize\", updateDimensions);\n\n    return () => {\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, []);\n\n  // Main animation logic\n  useEffect(() => {\n    if (!canvasRef.current || dimensions.width === 0 || dimensions.height === 0 || !mounted) return;\n\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Set canvas dimensions\n    canvas.width = dimensions.width;\n    canvas.height = dimensions.height;\n\n    // Define theme colors\n    const themeColors: ThemeColors =\n      theme === \"dark\"\n        ? {\n            background: \"#000000\",\n            meteorHead: \"rgba(255, 255, 255, 1)\",\n            meteorTailStart: \"rgba(255, 255, 255, 1)\",\n            meteorTailMiddle: \"rgba(255, 240, 200, 0.8)\",\n            meteorTailEnd: \"rgba(255, 200, 100, 0.1)\"\n          }\n        : {\n            background: \"#ffffff\", // Light blue sky\n            meteorHead: \"rgba(70, 90, 120, 1)\",\n            meteorTailStart: \"rgba(70, 90, 120, 1)\",\n            meteorTailMiddle: \"rgba(100, 120, 150, 0.8)\",\n            meteorTailEnd: \"rgba(130, 150, 180, 0.1)\"\n          };\n\n    // Create meteors with varied starting positions\n    const createMeteor = (): Meteor => {\n      // Determine a random starting position across the screen\n      // We'll use different edges and positions for variety\n\n      // Random position factor (0-1)\n      const positionFactor = Math.random();\n\n      // Choose a starting position based on screen dimensions\n      let x, y;\n\n      // Start from left side of screen\n      if (positionFactor < 0.25) {\n        x = -20;\n        y = dimensions.height * Math.random() * 0.7; // Random position on left edge\n      }\n      // Start from top of screen\n      else if (positionFactor < 0.5) {\n        x = dimensions.width * Math.random();\n        y = -20; // Just above the top edge\n      }\n      // Start from right side of screen\n      else if (positionFactor < 0.75) {\n        x = dimensions.width + 20;\n        y = dimensions.height * Math.random() * 0.7; // Random position on right edge\n      }\n      // Start from middle-top area\n      else {\n        x = dimensions.width * 0.3 + Math.random() * dimensions.width * 0.4; // Middle 40% of screen width\n        y = -20;\n      }\n\n      // Random size between 1 and 3\n      const size = 1 + Math.random() * 10;\n\n      // Medium-slow speed (consistent for all meteors)\n      const speed = 3;\n\n      // Fixed angle for consistent direction (45 degrees in radians)\n      const angle = Math.PI / 4;\n\n      // Fixed tail length\n      const tailLength = 15;\n\n      return {\n        x,\n        y,\n        size,\n        speed,\n        angle,\n        opacity: 0.7 + Math.random() * 0.3,\n        tail: [],\n        tailLength\n      };\n    };\n\n    // Initialize meteors\n    meteorsRef.current = Array.from({ length: 5 }, createMeteor);\n\n    // Animation loop\n    const animate = () => {\n      // Fill with theme background\n      ctx.fillStyle = themeColors.background;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Update and draw meteors\n      meteorsRef.current.forEach((meteor, index) => {\n        // Update position\n        meteor.x += Math.cos(meteor.angle) * meteor.speed;\n        meteor.y += Math.sin(meteor.angle) * meteor.speed;\n\n        // Add current position to tail\n        meteor.tail.unshift({ x: meteor.x, y: meteor.y });\n\n        // Limit tail length\n        if (meteor.tail.length > meteor.tailLength) {\n          meteor.tail.pop();\n        }\n\n        // Draw meteor tail (gradient line)\n        if (meteor.tail.length > 1) {\n          ctx.beginPath();\n\n          // Create gradient for tail\n          const gradient = ctx.createLinearGradient(\n            meteor.tail[0].x,\n            meteor.tail[0].y,\n            meteor.tail[meteor.tail.length - 1].x,\n            meteor.tail[meteor.tail.length - 1].y\n          );\n\n          gradient.addColorStop(0, themeColors.meteorTailStart.replace(\"1)\", `${meteor.opacity})`));\n          gradient.addColorStop(\n            0.3,\n            themeColors.meteorTailMiddle.replace(\"0.8)\", `${meteor.opacity * 0.8})`)\n          );\n          gradient.addColorStop(\n            1,\n            themeColors.meteorTailEnd.replace(\"0.1)\", `${meteor.opacity * 0.1})`)\n          );\n\n          ctx.strokeStyle = gradient;\n          ctx.lineWidth = meteor.size;\n\n          // Draw the tail path\n          ctx.moveTo(meteor.tail[0].x, meteor.tail[0].y);\n          for (let i = 1; i < meteor.tail.length; i++) {\n            ctx.lineTo(meteor.tail[i].x, meteor.tail[i].y);\n          }\n\n          ctx.stroke();\n        }\n\n        // Draw meteor head (small circle)\n        ctx.beginPath();\n        ctx.arc(meteor.x, meteor.y, meteor.size / 2, 0, Math.PI * 2);\n        ctx.fillStyle = themeColors.meteorHead.replace(\"1)\", `${meteor.opacity})`);\n        ctx.fill();\n\n        // Reset meteor if it goes off screen\n        if (meteor.y > dimensions.height || meteor.x < -50 || meteor.x > dimensions.width + 50) {\n          meteorsRef.current[index] = createMeteor();\n        }\n      });\n\n      // Add new meteors randomly\n      if (Math.random() < 0.02 && meteorsRef.current.length < 12) {\n        meteorsRef.current.push(createMeteor());\n      }\n\n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    // Cleanup\n    return () => {\n      cancelAnimationFrame(animationRef.current);\n    };\n  }, [dimensions, theme, mounted]);\n\n  return (\n    <div className={cn(\"relative w-full\", className)}>\n      <canvas\n        ref={canvasRef}\n        className=\"absolute h-full w-full\"\n        style={{ display: dimensions.width > 0 ? \"block\" : \"none\" }}\n      />\n      <div className=\"z-10\">{children}</div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/meteor-shower.tsx"
    },
    {
      "path": "lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib"
    }
  ]
}